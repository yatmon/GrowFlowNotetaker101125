{"name": "index.ts", "content": "import \"jsr:@supabase/functions-js/edge-runtime.d.ts\";\nimport { createClient } from \"npm:@supabase/supabase-js@2\";\n\nconst corsHeaders = {\n  \"Access-Control-Allow-Origin\": \"*\",\n  \"Access-Control-Allow-Methods\": \"POST, OPTIONS\",\n  \"Access-Control-Allow-Headers\": \"Content-Type, Authorization, X-Client-Info, Apikey\",\n};\n\ninterface TaskData {\n  description: string;\n  assignee_name?: string;\n  priority?: \"Low\" | \"Medium\" | \"High\";\n  status?: \"Not Started\" | \"In Progress\" | \"Done\";\n  deadline?: string;\n}\n\ninterface DirectRequestBody {\n  user_id: string;\n  tasks: TaskData[];\n}\n\ninterface N8nRequestBody {\n  user_id: string;\n  note_text: string;\n  note_id?: string;\n  default_priority?: \"Low\" | \"Medium\" | \"High\";\n}\n\ntype RequestBody = DirectRequestBody | N8nRequestBody;\n\nfunction isDirectRequest(body: RequestBody): body is DirectRequestBody {\n  return 'tasks' in body && Array.isArray(body.tasks);\n}\n\nfunction isN8nRequest(body: RequestBody): body is N8nRequestBody {\n  return 'note_text' in body && typeof body.note_text === 'string';\n}\n\nfunction parseNotesBasic(noteText: string, defaultPriority: \"Low\" | \"Medium\" | \"High\" = 'Medium'): TaskData[] {\n  console.log('Using basic note parser (no AI)');\n  const tasks: TaskData[] = [];\n  const lines = noteText.split('\\n').filter(line => line.trim());\n\n  for (const line of lines) {\n    const trimmed = line.trim();\n\n    if (trimmed.length === 0) continue;\n\n    let description = trimmed.replace(/^[-*\u2022]\\s*/, '');\n    let assignee_name: string | undefined;\n    let priority: \"Low\" | \"Medium\" | \"High\" = defaultPriority;\n    let deadline: string | undefined;\n\n    const assigneeMatch = description.match(/^\\*{0,2}([A-Z][a-z]+(?:\\s+[A-Z][a-z]+)*)\\*{0,2}:\\s*(.+)$/);\n    if (assigneeMatch) {\n      assignee_name = assigneeMatch[1];\n      description = assigneeMatch[2];\n    }\n\n    if (/(urgent|asap|critical|high priority|important)/i.test(description)) {\n      priority = 'High';\n    } else if (/(low priority|when possible|eventually|nice to have)/i.test(description)) {\n      priority = 'Low';\n    }\n\n    const datePatterns = [\n      /(?:by|before|due|deadline:?)\\s*(\\d{4}-\\d{2}-\\d{2})/i,\n      /(?:by|before|due|deadline:?)\\s*([A-Z][a-z]+\\s+\\d{1,2})/i,\n      /(?:by|before|due|deadline:?)\\s*(\\d{1,2}[-/]\\d{1,2}(?:[-/]\\d{2,4})?)/i,\n    ];\n\n    for (const pattern of datePatterns) {\n      const dateMatch = description.match(pattern);\n      if (dateMatch) {\n        try {\n          const dateStr = dateMatch[1];\n\n          if (/^\\d{4}-\\d{2}-\\d{2}$/.test(dateStr)) {\n            deadline = dateStr;\n          }\n          else if (/^[A-Z][a-z]+\\s+\\d{1,2}$/.test(dateStr)) {\n            const [monthStr, day] = dateStr.split(' ');\n            const year = new Date().getFullYear();\n            const monthMap: {[key: string]: number} = {\n              'Jan': 0, 'Feb': 1, 'Mar': 2, 'Apr': 3, 'May': 4, 'Jun': 5,\n              'Jul': 6, 'Aug': 7, 'Sep': 8, 'Oct': 9, 'Nov': 10, 'Dec': 11\n            };\n            const month = monthMap[monthStr.substring(0, 3)];\n            if (month !== undefined) {\n              const date = new Date(year, month, parseInt(day));\n              deadline = date.toISOString().split('T')[0];\n            }\n          }\n          else if (/^\\d{1,2}[-/]\\d{1,2}$/.test(dateStr)) {\n            const parts = dateStr.split(/[-/]/);\n            const year = new Date().getFullYear();\n            const date = new Date(year, parseInt(parts[0]) - 1, parseInt(parts[1]));\n            deadline = date.toISOString().split('T')[0];\n          }\n        } catch (e) {\n          console.warn('Failed to parse date:', dateMatch[1], e);\n        }\n        break;\n      }\n    }\n\n    description = description\n      .replace(/\\b(urgent|asap|critical|high priority|low priority|when possible|eventually|important|nice to have)\\b/gi, '')\n      .replace(/(?:by|before|due|deadline:?)\\s*(\\d{4}-\\d{2}-\\d{2})/gi, '')\n      .replace(/(?:by|before|due|deadline:?)\\s*([A-Z][a-z]+\\s+\\d{1,2})/gi, '')\n      .replace(/(?:by|before|due|deadline:?)\\s*(\\d{1,2}[-/]\\d{1,2}(?:[-/]\\d{2,4})?)/gi, '')\n      .replace(/\\s+/g, ' ')\n      .trim();\n\n    if (description.length > 0) {\n      tasks.push({\n        description,\n        assignee_name,\n        priority,\n        status: 'Not Started',\n        deadline,\n      });\n    }\n  }\n\n  if (tasks.length === 0 && noteText.trim().length > 0) {\n    tasks.push({\n      description: noteText.trim(),\n      priority: defaultPriority,\n      status: 'Not Started',\n    });\n  }\n\n  return tasks;\n}\n\nasync function parseNotesWithOpenAI(noteText: string, openAiKey: string, defaultPriority: \"Low\" | \"Medium\" | \"High\" = 'Medium'): Promise<TaskData[]> {\n  try {\n    const today = new Date().toISOString().split('T')[0];\n    const response = await fetch('https://api.openai.com/v1/chat/completions', {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'Authorization': `Bearer ${openAiKey}`,\n      },\n      body: JSON.stringify({\n        model: 'gpt-4o-mini',\n        messages: [\n          {\n            role: 'system',\n            content: `You are a task extraction assistant. Extract actionable tasks from meeting notes and return them as a JSON array.\\n\\nToday's date is: ${today}\\n\\nEach task should have:\\n- description (string, required): The task description\\n- assignee_name (string, optional): Person's name if mentioned\\n- priority (\\\"Low\\\" | \\\"Medium\\\" | \\\"High\\\", optional): Task priority, default ${defaultPriority}. Only override this if the note explicitly mentions a different priority.\\n- status (\\\"Not Started\\\" | \\\"In Progress\\\" | \\\"Done\\\", optional): Default \\\"Not Started\\\"\\n- deadline (string, optional): Date in YYYY-MM-DD format if mentioned. Convert relative dates like \\\"next Friday\\\", \\\"tomorrow\\\", \\\"in 2 weeks\\\" to absolute dates based on today's date.\\n\\nReturn ONLY a valid JSON array of tasks, nothing else. If no tasks found, return empty array [].`\n          },\n          {\n            role: 'user',\n            content: noteText\n          }\n        ],\n        temperature: 0.3,\n      }),\n    });\n\n    if (!response.ok) {\n      const errorText = await response.text();\n      console.error('OpenAI API error:', errorText);\n      throw new Error(`OpenAI API failed: ${response.status}`);\n    }\n\n    const data = await response.json();\n    const content = data.choices[0]?.message?.content;\n\n    if (!content) {\n      return [];\n    }\n\n    let tasks: TaskData[];\n    try {\n      const cleanContent = content.replace(/```json\\n?/g, '').replace(/```\\n?/g, '').trim();\n      tasks = JSON.parse(cleanContent);\n    } catch (parseError) {\n      console.error('Failed to parse OpenAI response:', content);\n      return [];\n    }\n\n    return Array.isArray(tasks) ? tasks : [];\n  } catch (error) {\n    console.error('Error parsing notes with OpenAI:', error);\n    throw error;\n  }\n}\n\nDeno.serve(async (req: Request) => {\n  if (req.method === \"OPTIONS\") {\n    return new Response(null, {\n      status: 200,\n      headers: corsHeaders,\n    });\n  }\n\n  try {\n    const supabaseUrl = Deno.env.get(\"SUPABASE_URL\")!;\n    const supabaseServiceKey = Deno.env.get(\"SUPABASE_SERVICE_ROLE_KEY\")!;\n    const openAiKey = Deno.env.get(\"OPENAI_API_KEY\");\n    \n    const supabase = createClient(supabaseUrl, supabaseServiceKey);\n\n    const body: RequestBody = await req.json();\n    \n    if (!body.user_id) {\n      return new Response(\n        JSON.stringify({ error: \"user_id is required\" }),\n        {\n          status: 400,\n          headers: { ...corsHeaders, \"Content-Type\": \"application/json\" },\n        }\n      );\n    }\n\n    let tasks: TaskData[] = [];\n\n    if (isDirectRequest(body)) {\n      console.log('Processing direct task insertion');\n      tasks = body.tasks;\n    } else if (isN8nRequest(body)) {\n      console.log('Processing notes with AI');\n      const defaultPriority = body.default_priority || 'Medium';\n\n      if (!openAiKey) {\n        console.log('No OpenAI key found, using basic parser');\n        tasks = parseNotesBasic(body.note_text, defaultPriority);\n      } else {\n        try {\n          tasks = await parseNotesWithOpenAI(body.note_text, openAiKey, defaultPriority);\n        } catch (aiError) {\n          console.error('OpenAI parsing failed, falling back to basic parser:', aiError);\n          tasks = parseNotesBasic(body.note_text, defaultPriority);\n        }\n      }\n\n      if (body.note_id) {\n        const { error: noteError } = await supabase\n          .from('notes')\n          .update({ processed: true })\n          .eq('id', body.note_id);\n\n        if (noteError) {\n          console.error('Error updating note:', noteError);\n        }\n      }\n    } else {\n      return new Response(\n        JSON.stringify({ error: \"Invalid request format\" }),\n        {\n          status: 400,\n          headers: { ...corsHeaders, \"Content-Type\": \"application/json\" },\n        }\n      );\n    }\n\n    if (tasks.length === 0) {\n      return new Response(\n        JSON.stringify({\n          success: true,\n          created: 0,\n          tasks: [],\n          message: 'No actionable tasks found in the notes',\n        }),\n        {\n          status: 200,\n          headers: { ...corsHeaders, \"Content-Type\": \"application/json\" },\n        }\n      );\n    }\n\n    const createdTasks = [];\n    const errors = [];\n\n    for (const task of tasks) {\n      try {\n        let assignee_id = null;\n        if (task.assignee_name) {\n          const { data: profiles } = await supabase\n            .from(\"profiles\")\n            .select(\"id, full_name\")\n            .ilike(\"full_name\", `%${task.assignee_name}%`)\n            .limit(1)\n            .maybeSingle();\n\n          if (profiles) {\n            assignee_id = profiles.id;\n            console.log(`Matched assignee \\\"${task.assignee_name}\\\" to profile: ${profiles.full_name}`);\n          } else {\n            console.log(`No profile found for assignee: ${task.assignee_name}`);\n          }\n        }\n\n        let deadline = null;\n        if (task.deadline) {\n          try {\n            deadline = new Date(task.deadline).toISOString().split('T')[0];\n          } catch (dateError) {\n            console.error(`Invalid deadline format: ${task.deadline}`);\n          }\n        }\n\n        const taskInsert: any = {\n          user_id: body.user_id,\n          assignee_id: assignee_id || body.user_id,\n          description: task.description,\n          priority: task.priority || \"Medium\",\n          status: task.status || \"Not Started\",\n          deadline,\n        };\n\n        if (isN8nRequest(body) && body.note_id) {\n          taskInsert.note_id = body.note_id;\n        }\n\n        const { data: newTask, error: insertError } = await supabase\n          .from(\"tasks\")\n          .insert(taskInsert)\n          .select()\n          .single();\n\n        if (insertError) {\n          console.error('Task insertion error:', insertError);\n          errors.push({ task: task.description, error: insertError.message });\n        } else {\n          createdTasks.push(newTask);\n          console.log(`Created task: ${task.description}`);\n\n          if (newTask.assignee_id && newTask.assignee_id !== null) {\n            const { error: notificationError } = await supabase\n              .from(\"notifications\")\n              .insert({\n                recipient_id: newTask.assignee_id,\n                actor_id: body.user_id,\n                type: 'assigned',\n                task_id: newTask.id,\n                message: `You've been assigned: ${newTask.description}`,\n                read: false,\n              });\n\n            if (notificationError) {\n              console.error('Notification insertion error:', notificationError);\n            } else {\n              console.log(`Notification created for assignee: ${newTask.assignee_id}`);\n            }\n          }\n        }\n      } catch (taskError) {\n        console.error('Task processing error:', taskError);\n        errors.push({ task: task.description, error: String(taskError) });\n      }\n    }\n\n    const response = {\n      success: true,\n      created: createdTasks.length,\n      tasks: createdTasks,\n      errors: errors.length > 0 ? errors : undefined,\n    };\n\n    console.log('Final response:', JSON.stringify(response, null, 2));\n\n    return new Response(\n      JSON.stringify(response),\n      {\n        status: 200,\n        headers: { ...corsHeaders, \"Content-Type\": \"application/json\" },\n      }\n    );\n  } catch (error) {\n    console.error(\"Unhandled error:\", error);\n    return new Response(\n      JSON.stringify({ \n        error: String(error),\n        details: error instanceof Error ? error.message : 'Unknown error',\n      }),\n      {\n        status: 500,\n        headers: { ...corsHeaders, \"Content-Type\": \"application/json\" },\n      }\n    );\n  }\n});"}
